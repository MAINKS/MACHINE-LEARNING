# -*- coding: utf-8 -*-
"""multiple_linear0_regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GWubi_QW_tUiaWjjGAeiTCHKnUUZ37Y7

#**Model 2**

# Multiple Linear Regression

50_Startups.csv : We have 3 independent & 1 dependent variable in our dataset that establishes Non linear relation b/w them. - Maximise profit depending upon New york or florida in state column.

Multiple Linear regression have non linear relation b/w data columns having independent & dependent variables.

y=b0+b1x1+b2x2+---bnxn - b=slope constant , x=independent variables

Linear regression - Yield of potatoes(y) based on nitrogen fertilisers

Multiple linear regression: Yield of potatoes(y) based on nitrogen fertiliser(x1) & temp (x2) & rain(x3).

State-Newyork/California is the categorical data & can't be occupied in Y=b0+b1x1+--- equation. So, We need to create DUMMY VARIABLES for this data as (1-NewYork, 0-California)
and this 0,1 will be used as b4x4 - x4=1 Newyork operated else california. That's how dummy varible works.

You can not include both dummy variables at the same time (Dummy Variable Trap) - as using one will eventually make second 0. Always omit one dummy variable ,(n-1) dummy var to be used.

If no of Catogorical column increases, then no of dummy variable also increased.

We need to get rid of those columns that doesn't affect much the dependent variable in general.

Too many inputs for a ML model makes it work unefficiently , not reliable and work like what actually required (Remove Garbage model).

Important variables that actually predict something is preserved for choosing variable in a model

**Building a Model** (removing unnecessary variables)
All in- all variables included
Backward elimination - decreases no of variables
Forward selection - increases no of variables
Bidirectional elimination - combination of upper two
Score Comparison

As no of variables removed increases , factors affecting dependent var also changes.

Gonna perform Backward Elimination in here. (Fastest)

Scikit learn library will help remove the dummy var trap.
Out of 3 columns encoded into numerical val from categorcial val of the state column , Advanced implentation of scikit learn lib will build model using outcasting one column out of 3 & overcoming dummy var trap.

After training on train set , test set is used to check accuracy & efficency of model.

Plot b/w X & y not possible in multiple linear regression as multiple features can't be plotted all together.

Predicting vector to be created for visualising.

## Importing the libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""## Importing the dataset"""

dataset = pd.read_csv('50_Startups.csv')
X=dataset.iloc[:,:-1].values
y=dataset.iloc[:,-1].values

print(X)

"""## Encoding categorical data"""

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
ct=ColumnTransformer(transformers=[('encoder',OneHotEncoder(),[3])],remainder='passthrough')
X = np.array(ct.fit_transform(X))

print(X)

"""## Splitting the dataset into the Training set and Test set"""

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(X , y , test_size=0.2 , random_state=0)

"""## Training the Multiple Linear Regression model on the Training set"""

from sklearn.linear_model import LinearRegression
regressor=LinearRegression()
regressor.fit(X_train,y_train)

"""## Predicting the Test set results"""

#(1) Concatenate is the function/classic trick of numpy that helps us to concatenate two vectors or even array
#horizontally or vertically (arguments-two vectors to concatenate)
#(2)Gonna concatenate two vectors predcited and real profits , also predicted values are printed horizontally , it's
#required to transform them vertically before concatenating using "reshape" function with parameters as no of rows that
# are gonna transformed to column and column no.

#y_pred contains predicted values for corresponding matrix X
#y_test contains actual data for corresponding x matrix

#Also axis as argument also to be provided , 0-Vertical concatenation ,1-horizontal concatenation


y_pred = regressor.predict(X_test)
np.set_printoptions(precision=2)
print(np.concatenate((y_pred.reshape(len(y_pred),1),y_test.reshape(len(y_test),1)),1))

#These obtained values are Predicted value on left & Actual value on right for X_test

#Tuning of model is done via Backward Elimination.

"""# EXTRAS

As students progress from learning Linear Regression to Multiple Linear Regression there are a few common questions that arise.

This free bonus tackles two of the most frequently asked Multiple Linear Regression-related questions that we hear from students on their Machine Learning journey.

Question 1: How do I use my multiple linear regression model to make a single prediction, for example, the profit of a startup with R&D Spend = 160000, Administration Spend = 130000, Marketing Spend = 300000 and State = California?

Question 2: How do I get the final regression equation y = b0 + b1 x1 + b2 x2 + ... with the final values of the coefficients?

# Making a single prediction (for example the profit of a startup with R&D Spend = 160000, Administration Spend = 130000, Marketing Spend = 300000 and State = 'California')
"""

print(regressor.predict([[1, 0, 0, 160000, 130000, 300000]]))

"""Therefore, our model predicts that the profit of a Californian startup which spent 160000 in R&D, 130000 in Administration and 300000 in Marketing is $ 181566,92.

Important note 1: Notice that the values of the features were all input in a double pair of square brackets. That's because the "predict" method always expects a 2D array as the format of its inputs. And putting our values into a double pair of square brackets makes the input exactly a 2D array. Simply put:

1,0,0,160000,130000,300000→scalars

[1,0,0,160000,130000,300000]→1D array

[[1,0,0,160000,130000,300000]]→2D array

Important note 2: Notice also that the "California" state was not input as a string in the last column but as "1, 0, 0" in the first three columns. That's because of course the predict method expects the one-hot-encoded values of the state, and as we see in the second row of the matrix of features X, "California" was encoded as "1, 0, 0". And be careful to include these values in the first three columns, not the last three ones, because the dummy variables are always created in the first columns.

# Getting the final linear regression equation with the values of the coefficients
"""

print(regressor.coef_)
print(regressor.intercept_)

"""Therefore, the equation of our multiple linear regression model is:

Profit=86.6×Dummy State 1−873×Dummy State 2+786×Dummy State 3+0.773×R&D Spend+0.0329×Administration+0.0366×Marketing Spend+42467.53

Important Note: To get these coefficients we called the "coef_" and "intercept_" attributes from our regressor object. Attributes in Python are different than methods and usually return a simple value or an array of values.

#  BackWard Elimination :
  
  As I explained in the previous tutorial, Backward Elimination is irrelevant in Python, because the Scikit-Learn library automatically takes care of selecting the statistically significant features when training the model to make accurate predictions.

However, if you do really want to learn how to manually implement Backward Elimination in Python and identify the most statistically significant features, please find in this link below some old videos I made on how to implement Backward Elimination in Python:

https://www.dropbox.com/sh/pknk0g9yu4z06u7/AADSTzieYEMfs1HHxKHt9j1ba?dl=0

These are old videos made on Spyder but the dataset and the code are the same as in the previous video lectures of this section on Multiple Linear Regression, except that I had manually removed the first column to avoid the Dummy Variable Trap with this line of code:

# Avoiding the Dummy Variable Trap
X = X[:, 1:]
Just keep this for this Backward Elimination implementation, but keep in mind that in general you don't have to remove manually a dummy variable column because Scikit-Learn takes care of it.

And also, please find the whole code implementing this Backward Elimination technique:

# Multiple Linear Regression

# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv('50_Startups.csv')
X = dataset.iloc[:, :-1].values
y = dataset.iloc[:, -1].values
print(X)

# Encoding categorical data
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [3])], remainder='passthrough')
X = np.array(ct.fit_transform(X))
print(X)

# Avoiding the Dummy Variable Trap
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Training the Multiple Linear Regression model on the Training set
from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

# Predicting the Test set results
y_pred = regressor.predict(X_test)
np.set_printoptions(precision=2)
print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

# Building the optimal model using Backward Elimination
import statsmodels.api as sm
X = np.append(arr = np.ones((50, 1)).astype(int), values = X, axis = 1)
X_opt = X[:, [0, 1, 2, 3, 4, 5]]
X_opt = X_opt.astype(np.float64)
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()X_opt = X[:, [0, 1, 3, 4, 5]]
X_opt = X_opt.astype(np.float64)
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()X_opt = X[:, [0, 3, 4, 5]]
X_opt = X_opt.astype(np.float64)
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()X_opt = X[:, [0, 3, 5]]
X_opt = X_opt.astype(np.float64)
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()X_opt = X[:, [0, 3]]
X_opt = X_opt.astype(np.float64)regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()
Once again, this is totally optional.
"""